---
title: "Transform"
author: "John Yang"
output: html_notebook
---

# First install the packages
```{r}
install.packages("tidyverse")
install.packages("nycflights13")
```

# Now call the libraries

````{r}
library(nycflights13)
library(tidyverse)
```

# Now define a tibble. Pay attention to the differnt types of variables [integers<int>, doubles<dbl>, characters<chr>, data-times<dttm>, logical<lgl>, factors<fctr>, dates<date>]. 

````{r}
flights <- flights
flights 
# State the obvious~
# How many variables do we have in the tibble?
# How many observations do we have in the tibble?
```

# If you want to see the whole dataset

````{r}
#view(flights)
```

# Introduction of basic tidyverse verbs in the dplyr package

filter (Tuesday)

arrange (Tuesday)

mutate (Thursday)

select (Thursday)

group_by (Thursday)

summarize (Thursday)

# Let's try out filter() first
# filter() is all about "selecting" observations without making any change on the variables. 

Filter in all flights that departed on Jan 1, 2013

````{r}
( jan1 = filter(flights, month == 1, day == 1) )
```

Note that:

1. what does "==" mean? Can we use "=" instead?

2. "logical operators"

or: "|" 

and: "&" 

not: "!"

3. "comparison operators"

greater than: ">" 

less than: "<" 

equal to: "=="

3. What if you want to select both day == 1 and day == 2? (Be careful!)

A quick test:

Suppose we want to collect the flight information on the first two days of Jan (i.e. Jan 1st and Jan 2nd).
Which one of the following two commands will give us what we want? 

Choice-A

````{r}
( jan1 = filter(flights, month == 1, day == 1 | day == 2) )
```

Choice-B

````{r}
( jan1 = filter(flights, month == 1, day == 1 & day == 2) )
```

2 mins individual exercise (post in slack after finished):

We want to find flights that aren't delayed on departure by more than 120 minutes?

Hint: the variable, dep_delay, describes how many minutes has the flight departure been delayed.

````{r}
( jan1 = filter(flights, !(dep_delay > 120)))
```

Finally, if we have missing data, is.na() function will help us identify them. Like the following example:

````{r}
( jan1 = filter(flights, is.na(dep_time)))
```

A quick recap for filter():

1. "==" is different from "=" 


2. Comparison operators: And Or Not


3. Be careful with natural vs. programming language.


4. is.na() will help us identify missing data.

Three filter() challenges:

1. Find the flights that flew from New York JFK to Houston (IAH or HOU)
Hint-1: the variable, origin, indicates the departure city.
Hint-2: the variable, dest, indicates the arrival city.

2. Find the flights that departed in summer (July, August, and September)

3. Find the flights that got delayed but managed to make up?
Hint-1: What variables can help you quantitatively define "delay"? (i.e., dep_delay and arr_delay)
Hint-2: how to define "make up"?

Flew from New York JFK to Houston (IAH or HOU)

````{r}
( jan1 = filter(flights, origin == "JFK",  dest == "IAH" | dest == "HOU" ))
```

Departed in summer (July, August, and September)

````{r}
( jan1 = filter(flights, month == 7 | month == 8 | month == 9))
```

Find the flights that got delayed but managed to make up:

````{r}
( make_up_0 = filter(flights, dep_delay > 0 & arr_delay-dep_delay < 0))
```

# Now, let's work on arrange()

````{r}
# Sort flights to find the shortest flight.
arrange(flights, dep_delay)
# Sort flights to find the most delayed departure flight.
arrange(flights, desc(dep_delay))
```

Individual exercise (3 mins) 

Sort flights to find the fastest (highest speed) flight in July.
hint: 1. Speed is not a variable in the existing data table.
hint: 2. Speed is defined as "distance" over "air_time". Both variables can be found in flights.

````{r}
july1 = filter(flights, month == 7)
arrange(july1, desc(distance/air_time))
```

#Thursday Lecture: 

Individual exercise on fliter():

In the "flights" tibble, for the flights that got delayed, were they more likely to make up by at least 30 mins or get further delayed by at least 30 mins? 
Hint: "dep_delay" refers to how many minutes does a flight get delayed in departure. "arr_delay" refers to how many minutes does a flight get delayed in arrival. 

````{r}
( further_delay_30 <- filter(flights, dep_delay >= 0 & arr_delay-dep_delay >= 50))
( make_up_30 <- filter(flights, dep_delay >= 0 & arr_delay-dep_delay <= -50))
```


# Find the variables you are interested in using select(). Note: Be aware of the number of variables.

````{r}

flights
# select three variables year, month, and day

select(flights, year, month, day)
# you can use "-" to eliminate variables

select(flights, -(year:dep_time))

# helper functions: contains, starts_with, ends_with
select(flights, contains("dep"))
# select(flights, starts_with("dep"))
# select(flights, ends_with("dep"))

```

# Add new variables with mutate(). Add new variables that are derived from existing variables. 

````{r}
# Here we want to create a new table. 
# The new table, flights_speed, will contain multiple variables from flights.
# The new table will also add one more variable "speed" that is derived from distance and air_time
(flights_speed <- select(flights, year:day, distance, air_time))

mutate(flights_speed, speed_mile_per_mins = distance / air_time, speed_mile_per_hours = distance / air_time * 60)
```

Exercise: Find out how much a summer-2013 NYC flight can catch up in the air!

1. Create a new tibble, flights_delay, to include year, month, day, and the variables that end with "delay".
2. Find all flights that departed in summer, and save your results to a new tibble, flights_delay_summer
3. Add a new variable to flights_delay_summer, catch_up, that represents the difference between departure and arrival delay.
4. Arrange the table based on the time_gain and sort in a descending order. 

````{r}
(flights_delay <- select(flights, year, month, day, ends_with("delay")))
(flights_delay_summer <- filter(flights_delay, month == 7 | month == 8 | month == 9 ))
(flights_delay_summer <- mutate(flights_delay_summer, catch_up = dep_delay - arr_delay))
(flights_delay_summer <- arrange(flights_delay_summer, desc(catch_up)))
```

# Finally, Group_by and summarise()

````{r}
# learn average delay using summarise() 
summarise(flights, mean_delay = mean(dep_delay, na.rm = TRUE))
```

````{r}
# learn average delay for each month using summarise() and group_by() 
( by_month = group_by(flights, month) )
summarise(by_month, delay = mean(dep_delay, na.rm = TRUE))
```

````{r}
# Another example
(by_origin = group_by(flights, origin))
summarise(by_origin, delay = mean(dep_delay, na.rm = TRUE))
```
Question: how many groups do you expect to see in the following command? 12+3 =15 or 12*3 = 36

````{r}
by_month_origin = group_by(flights, month, origin)
summarise(by_month_origin, delay = mean(dep_delay, na.rm = TRUE))
```

Group Challenge: Explore the relationship between the distance and average delay for each destination in Julyï¼Ÿ
Hint: Think about the order of verbs you want to apply (summarise, group_by, filter, etc.).

````{r}
by_dest <- filter(flights, month == 7)
by_dest <- group_by(by_dest, dest)
delay <- summarise(by_dest,
  count = n(),
  dist = mean(distance, na.rm = TRUE),
  delay = mean(arr_delay, na.rm = TRUE)
)
arrange(delay, dist)
#ggplot(data = delay) + geom_point(mapping = aes(x = dist, y = delay, size = count), alpha = 1/3) + geom_smooth (mapping = aes(x = dist, y = delay), se = FALSE)
```

# Backup 
Additional challenge:

Find the most delayed (departure) flight in July?

````{r}
jan1 = filter(flights, month == 6)
arrange(jan1, desc(dep_delay))
```

How could you use arrange() to sort all missing values to the start? 

````{r}
arrange(flights, desc(is.na(dep_time)))
```

Were delayed by at least an hour, but made up over 30 minutes in flight

````{r}
( jan1 = filter(flights, dep_delay >= 60 & arr_delay-dep_delay <= -30))
```


````{r}
select(flights, contains("TIME"))
# variable ignore.case can tune the result
```

Plot distance versus flight speed? 
````{r}
#ggplot(data = flights) + 
#  geom_point(mapping = aes (x = distance, y = distance/air_time))
```

covid19.analytics
````{r}
install.packages("covid19.analytics")
```

````{r}
library(covid19.analytics)
```

````{r}
CV_US = covid19.US.data()
#(CV_US_state <- CV_US %>% group_by(Province_State) %>% summarise(across("2021-08-01":"2021-09-01", sum)) %>% arrange(desc(`2021-09-01`)))
(CV_US_state <- CV_US %>% 
    group_by(Province_State) %>% 
    summarise((across("2021-08-01":"2021-09-01", sum) - across("2021-07-31":"2021-08-31", sum))/across("2021-07-31":"2021-08-31", sum)) %>% 
    arrange(desc(`2021-09-01`)))
```